# Docker 网络

一个容器可以看到的网络栈，实际上是被隔离在自己 `Network Namespace` 中的
使用 `-net=host` 参数，直接使用宿主机网络栈

- 网卡
- 回环设备
- 路由表
- `iptables`

### 网桥

虚拟交换机，是一个工作在数据链路层的设备，主要根据 `MAC` 地址来将数据包转发到网桥不同的端口上
默认在宿主机上创建一个叫 `docker0`，凡是连接到这个网桥上的容器，可以通过它来通信

`Veth Pair` 虚拟设备，主要用来将容器连接到网桥上，总是成对出现的

```bash
docker run --name debian-1 -d debian tail -f /dev/null
docker run --name debian-2 -d debian tail -f /dev/null
```

```bash
# 物理机
docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether f2:3c:05:41:6b:5b brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::f03c:5ff:fe41:6b5b/64 scope link
       valid_lft forever preferred_lft forever
docker0         8000.f23c05416b5b       no              veth6b25653
                                                        veth76501de
# debian-1
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500                                                                                                                                                                                            
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 06:b7:3a:5e:0d:33  txqueuelen 0  (Ethernet)
        RX packets 4554  bytes 10482736 (9.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2916  bytes 160304 (156.5 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0

# debian-2
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 32:52:34:6c:30:68  txqueuelen 0  (Ethernet)
        RX packets 4235  bytes 10459476 (9.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2613  bytes 142695 (139.3 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
```

`eth0` 网卡，是一个 `Veth Pair` 一端在容器中，另一端被插在网桥上
虚拟网卡一旦被插在网桥上，就会被变成网桥的从设备；从设备会被剥夺调用网络协议处理数据包的资格，成为一个端口，只能接收流入的数据，数据的处理需要由网桥决定

##### 访问流程

被限制在 `Network Namespace` 里的容器进程，实际上是通过 `Veth Pair` 设备和宿主机网桥的方式，实现了和其他容器的数据交换
> 容器如果遇到网络问题，可以先试试网桥是否能 `ping` 通，查看和虚拟网卡有关的配置

- 从一个容器连接另一个容器
- `IP` 地址会匹配到第二条路由规则，网关为 `0.0.0.0`，这是一条直连规则
    - 匹配到该规则的 `IP` 包经过网卡，通过二层网络直接发向目的主机
- 网卡发送一个 `ARP` 广播，通过 `IP` 地址查找对应的 `MAC` 地址
- 网桥收到扮演交换机的角色，将 `ARP` 广播转发到其他虚拟网卡上
- 容器的网络协议栈会收到这个 `ARP` 请求，返回目标 `IP` 的 `MAC` 地址
- 获取目标的 `MAC` 地址，可以开始发送数据
- 由于 `Veth Pair` 设备原理，数据包会立即出现在虚拟网卡，虚拟网卡作为从设备失去转发能力，数据进入网桥
- 网桥根据 `MAC` 地址在 `CAM` 表查找对应端口，将数据包发送到这个端口

##### 跨主通信（网络覆盖）

默认配置下无法实现跨主机通信，需要使用软件创建一个公用网桥，把集群内的所有容器连接到这个网桥上
宿主机收到网络包后将其转发到正确的节点